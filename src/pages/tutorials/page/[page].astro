---
import { getCollection } from 'astro:content';
import TutorialsLayout from '@/layouts/TutorialsLayout.astro';
import PagePagination from '@/components/PagePagination.astro';

export async function getStaticPaths() {
  // Get all tutorials for pagination calculation
  const tutorials = await getCollection('tutorials', ({ data }) => {
    return data.draft !== true;
  });

  // Group tutorials by series
  const seriesMap = new Map();

  tutorials.forEach(tutorial => {
    const seriesName = tutorial.data.series;
    if (!seriesMap.has(seriesName)) {
      seriesMap.set(seriesName, {
        name: seriesName,
        parts: [],
        totalParts: tutorial.data.totalParts || 1,
        description: '',
        difficulty: tutorial.data.difficulty,
        tags: tutorial.data.tags || [],
        firstPartSlug: '',
        latestPublishDate: tutorial.data.publishDate
      });
    }
    
    const series = seriesMap.get(seriesName);
    series.parts.push(tutorial);
    
    // Use the first part's description and slug
    if (tutorial.data.part === 1) {
      series.description = tutorial.data.description;
      series.firstPartSlug = tutorial.slug;
    }
    
    // Update latest publish date
    if (new Date(tutorial.data.publishDate) > new Date(series.latestPublishDate)) {
      series.latestPublishDate = tutorial.data.publishDate;
    }
  });

  // Convert to array and sort by latest publish date
  const tutorialSeries = Array.from(seriesMap.values()).sort((a, b) => 
    new Date(b.latestPublishDate).getTime() - new Date(a.latestPublishDate).getTime()
  );

  const seriesPerPage = 6;
  const totalPages = Math.ceil(tutorialSeries.length / seriesPerPage);

  // Generate static paths for pages 2 and above
  const paths = [];
  for (let i = 2; i <= totalPages; i++) {
    paths.push({
      params: { page: i.toString() }
    });
  }

  return paths;
}

// Get page number from URL params
const { page } = Astro.params;
const currentPage = parseInt(page || '2');

// Get all tutorials, sorted by series and order
const tutorials = await getCollection('tutorials', ({ data }) => {
  return data.draft !== true;
});

// Group tutorials by series
const seriesMap = new Map();

tutorials.forEach(tutorial => {
  const seriesName = tutorial.data.series;
  if (!seriesMap.has(seriesName)) {
    seriesMap.set(seriesName, {
      name: seriesName,
      parts: [],
      totalParts: tutorial.data.totalParts || 1,
      description: '',
      difficulty: tutorial.data.difficulty,
      tags: tutorial.data.tags || [],
      firstPartSlug: '',
      latestPublishDate: tutorial.data.publishDate
    });
  }
  
  const series = seriesMap.get(seriesName);
  series.parts.push(tutorial);
  
  // Use the first part's description and slug
  if (tutorial.data.part === 1) {
    series.description = tutorial.data.description;
    series.firstPartSlug = tutorial.slug;
  }
  
  // Update latest publish date
  if (new Date(tutorial.data.publishDate) > new Date(series.latestPublishDate)) {
    series.latestPublishDate = tutorial.data.publishDate;
  }
});

// Convert to array and sort by latest publish date
const tutorialSeries = Array.from(seriesMap.values()).sort((a, b) => 
  new Date(b.latestPublishDate).getTime() - new Date(a.latestPublishDate).getTime()
);

// Sort parts within each series
tutorialSeries.forEach(series => {
  series.parts.sort((a, b) => a.data.part - b.data.part);
});

// Calculate tag popularity (top 3 most used tags)
const tagCounts = new Map();
tutorials.forEach(tutorial => {
  tutorial.data.tags?.forEach(tag => {
    tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
  });
});

// Get top 3 most popular tags
const popularTags = Array.from(tagCounts.entries())
  .sort((a, b) => b[1] - a[1])
  .slice(0, 3)
  .map(([tag, count]) => ({ tag, count }));

// Get all unique tags for filtering
const allTags = Array.from(tagCounts.keys()).sort();

// Get all unique difficulties for filtering
const difficulties = Array.from(new Set(tutorials.map(tutorial => tutorial.data.difficulty).filter(Boolean))).sort();

// Pagination logic for series
const seriesPerPage = 6;
const totalPages = Math.ceil(tutorialSeries.length / seriesPerPage);
const startIndex = (currentPage - 1) * seriesPerPage;
const paginatedSeries = tutorialSeries.slice(startIndex, startIndex + seriesPerPage);

// Generate pagination URLs
const prevUrl = currentPage > 1 ? 
  (currentPage === 2 ? '/tutorials' : `/tutorials/page/${currentPage - 1}`) : 
  null;
const nextUrl = currentPage < totalPages ? `/tutorials/page/${currentPage + 1}` : null;
---

<TutorialsLayout 
  title={`Tutorials - Page ${currentPage} - codersbox`}
  description="Step-by-step tutorials for web development and programming."
  popularTags={popularTags}
  allTags={allTags}
  difficulties={difficulties}
>
  <!-- Main Content -->
  <main class="py-12">
    <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8">
      {paginatedSeries.length > 0 ? (
        <>
          <div id="tutorials-container">
            <div id="tutorials-grid" class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-12">
            {paginatedSeries.map((series) => (
              <article 
                class="tutorial-item bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 overflow-hidden shadow-sm hover:shadow-md transition-all duration-300 h-full flex"
                data-title={series.name.toLowerCase()}
                data-description={series.description.toLowerCase()}
                data-tags={JSON.stringify(series.tags || [])}
                data-difficulty={series.difficulty}
                data-date={series.latestPublishDate.getTime()}
              >
                <div class="w-2 bg-gray-900 dark:bg-gray-600"></div>
                <div class="p-6 flex-grow flex flex-col">
                  <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-3">
                      <span class={`inline-block text-xs px-3 py-1 rounded-full font-medium uppercase tracking-wide ${
                        series.difficulty === 'beginner' ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' :
                        series.difficulty === 'intermediate' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200' :
                        'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
                      }`}>
                        {series.difficulty}
                      </span>
                      <span class="bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs px-2 py-1 rounded-full font-medium">
                        {series.totalParts} parts
                      </span>
                    </div>
                    <time class="text-xs text-gray-500 dark:text-gray-400">
                      {new Date(series.latestPublishDate).toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric' 
                      })}
                    </time>
                  </div>
                  
                  <h3 class="font-bold text-lg mb-2 text-gray-900 dark:text-gray-100 leading-tight line-clamp-2">
                    <a href={`/tutorials/series/${series.name.toLowerCase().replace(/\s+/g, '-')}`} class="hover:underline">
                      {series.name}
                    </a>
                  </h3>
                  <p class="text-gray-600 dark:text-gray-400 text-sm mb-4 leading-relaxed line-clamp-3 flex-grow">
                    {series.description}
                  </p>
                  
                  <div class="flex flex-wrap gap-2 mb-4">
                    {series.tags.map((tag) => (
                      <span class="bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-3 py-1 text-xs font-medium">
                        {tag}
                      </span>
                    ))}
                  </div>
                  
                  <div class="flex items-center justify-between mt-auto">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center gap-3 text-xs text-gray-500 dark:text-gray-400">
                        <a 
                          href={`/tutorials/series/${series.name.toLowerCase().replace(/\s+/g, '-')}`}
                          class="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium inline-flex items-center transition-colors"
                        >
                          View Series
                          <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                          </svg>
                        </a>
                      </div>
                    </div>
                    {series.firstPartSlug && (
                      <a 
                        href={`/tutorials/${series.firstPartSlug}`}
                        class="bg-black hover:bg-gray-900 text-white px-4 py-2 rounded-lg text-sm font-medium inline-flex items-center transition-colors"
                      >
                        Start Reading
                        <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                      </a>
                    )}
                  </div>
                </div>
              </article>
            ))}
            </div>
            
            <!-- No Results Message -->
            <div id="no-results" class="text-center py-12 hidden">
              <div class="text-gray-400 dark:text-gray-500 mb-4">
                <svg class="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                </svg>
              </div>
              <h3 class="text-xl font-semibold text-gray-900 dark:text-gray-100 mb-2">No tutorials found</h3>
              <p class="text-gray-600 dark:text-gray-400 mb-4">Try adjusting your search or filters to find what you're looking for.</p>
              <button id="clear-all-filters" class="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 font-medium">
                Clear all filters
              </button>
            </div>
          </div>
          
          <!-- Pagination -->
          <div id="pagination-container">
            {totalPages > 1 && (
              <PagePagination 
                currentPage={currentPage}
                totalPages={totalPages}
                prevUrl={prevUrl}
                nextUrl={nextUrl}
              />
            )}
          </div>
        </>
      ) : (
        <div class="text-center py-12">
          <h3 class="text-xl font-semibold text-gray-900 dark:text-gray-100 mb-2">No tutorial series found</h3>
          <p class="text-gray-600 dark:text-gray-400">Check back later for new tutorial series!</p>
        </div>
      )}
    </div>
  </main>
</TutorialsLayout>

<script is:inline>
  // Enhanced search functionality for tutorials with type-ahead
  document.addEventListener('DOMContentLoaded', function() {
    const tutorials = Array.from(document.querySelectorAll('.tutorial-item'));
    const noResults = document.getElementById('no-results');
    const tutorialsGrid = document.getElementById('tutorials-grid');
    const popularTags = document.querySelectorAll('.popular-tag');
    const clearAllFilters = document.getElementById('clear-all-filters');
    const heroSearch = document.getElementById('hero-search');
    const searchSuggestions = document.getElementById('search-suggestions');
    const suggestionsList = document.getElementById('suggestions-list');
    
    // Build search index for type-ahead
    const searchIndex = new Set();
    let tutorialTitles = [];
    let tutorialTags = new Set();
    let tutorialSeries = new Set();
    let difficulties = new Set();
    
    function buildSearchIndex() {
      tutorials.forEach(tutorial => {
        const title = tutorial.dataset.title || '';
        const description = tutorial.dataset.description || '';
        const tags = JSON.parse(tutorial.dataset.tags || '[]');
        const difficulty = tutorial.dataset.difficulty || '';
        const series = tutorial.dataset.series || '';
        
        // Add title to tutorials list
        if (title) {
          tutorialTitles.push({
            title: title.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
            search: title.toLowerCase()
          });
        }
        
        // Add tags, series, and difficulties to sets
        tags.forEach(tag => tutorialTags.add(tag));
        if (difficulty) difficulties.add(difficulty);
        if (series) tutorialSeries.add(series);
        
        // Add individual words to search index
        const words = (title + ' ' + description + ' ' + tags.join(' ') + ' ' + difficulty + ' ' + series).toLowerCase().split(/\s+/);
        words.forEach(word => {
          if (word.length > 2) {
            searchIndex.add(word);
          }
        });
      });
    }
    
    buildSearchIndex();
    
    let selectedSuggestionIndex = -1;
    let currentSuggestions = [];
    
    function generateSuggestions(query) {
      if (!query || query.length < 2) return [];
      
      const queryLower = query.toLowerCase();
      const suggestions = [];
      
      // Add matching tutorial titles
      const matchingTitles = tutorialTitles
        .filter(item => item.search.includes(queryLower))
        .slice(0, 2);
      
      suggestions.push(...matchingTitles.map(item => ({
        text: item.title,
        type: 'tutorial',
        query: item.search
      })));
      
      // Add matching series
      const matchingSeries = Array.from(tutorialSeries)
        .filter(series => series.toLowerCase().includes(queryLower))
        .slice(0, 2);
      
      suggestions.push(...matchingSeries.map(series => ({
        text: series,
        type: 'series',
        query: series.toLowerCase()
      })));
      
      // Add matching difficulties
      const matchingDifficulties = Array.from(difficulties)
        .filter(difficulty => difficulty.toLowerCase().includes(queryLower))
        .slice(0, 2);
      
      suggestions.push(...matchingDifficulties.map(difficulty => ({
        text: difficulty.charAt(0).toUpperCase() + difficulty.slice(1),
        type: 'difficulty',
        query: difficulty.toLowerCase()
      })));
      
      // Add matching tags
      const matchingTags = Array.from(tutorialTags)
        .filter(tag => tag.toLowerCase().includes(queryLower))
        .slice(0, 2);
      
      suggestions.push(...matchingTags.map(tag => ({
        text: tag,
        type: 'tag',
        query: tag.toLowerCase()
      })));
      
      return suggestions.slice(0, 8);
    }
    
    function showSuggestions(suggestions) {
      if (suggestions.length === 0) {
        hideSuggestions();
        return;
      }
      
      currentSuggestions = suggestions;
      selectedSuggestionIndex = -1;
      
      const html = suggestions.map((suggestion, index) => {
        const typeIcon = suggestion.type === 'tutorial' ? '🎓' : 
                        suggestion.type === 'series' ? '📚' :
                        suggestion.type === 'difficulty' ? '📊' :
                        suggestion.type === 'tag' ? '🏷️' : '🔍';
        
        return `
          <div class="suggestion-item flex items-center px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0" data-index="${index}">
            <span class="mr-3 text-sm">${typeIcon}</span>
            <div class="flex-grow">
              <div class="text-sm font-medium text-gray-900 dark:text-gray-100">${suggestion.text}</div>
              <div class="text-xs text-gray-500 dark:text-gray-400 capitalize">${suggestion.type}</div>
            </div>
          </div>
        `;
      }).join('');
      
      suggestionsList.innerHTML = html;
      searchSuggestions.classList.remove('hidden');
      
      // Add click handlers
      document.querySelectorAll('.suggestion-item').forEach((item, index) => {
        item.addEventListener('click', () => selectSuggestion(index));
      });
    }
    
    function hideSuggestions() {
      searchSuggestions.classList.add('hidden');
      selectedSuggestionIndex = -1;
      currentSuggestions = [];
    }
    
    function selectSuggestion(index) {
      if (index >= 0 && index < currentSuggestions.length) {
        const suggestion = currentSuggestions[index];
        heroSearch.value = suggestion.query;
        hideSuggestions();
        searchTutorials();
        heroSearch.focus();
      }
    }
    
    function highlightSuggestion(index) {
      document.querySelectorAll('.suggestion-item').forEach((item, i) => {
        if (i === index) {
          item.classList.add('bg-gray-100', 'dark:bg-gray-700');
        } else {
          item.classList.remove('bg-gray-100', 'dark:bg-gray-700');
        }
      });
    }
    
    // Debounce function to avoid excessive filtering
    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
      };
    }
    
    function searchTutorials() {
      const searchTerm = heroSearch ? heroSearch.value.toLowerCase().trim() : '';
      
      if (!searchTerm) {
        // Show all tutorials when search is empty
        tutorials.forEach(function(tutorial) {
          tutorial.style.display = 'block';
        });
        noResults.classList.add('hidden');
        tutorialsGrid.classList.remove('hidden');
        return;
      }
      
      // Search through multiple fields with different weights
      let searchResults = tutorials.map(function(tutorial) {
        const title = (tutorial.dataset.title || '').toLowerCase();
        const description = (tutorial.dataset.description || '').toLowerCase();
        const tags = JSON.parse(tutorial.dataset.tags || '[]');
        const tagsString = tags.map(tag => tag.toLowerCase()).join(' ');
        const difficulty = (tutorial.dataset.difficulty || '').toLowerCase();
        
        let score = 0;
        
        // Title matches get highest score
        if (title.includes(searchTerm)) {
          score += title.indexOf(searchTerm) === 0 ? 10 : 5; // Boost if starts with search term
        }
        
        // Description matches get medium score
        if (description.includes(searchTerm)) {
          score += 3;
        }
        
        // Tag matches get lower score
        if (tagsString.includes(searchTerm)) {
          score += 2;
        }
        
        // Difficulty matches
        if (difficulty.includes(searchTerm)) {
          score += 2;
        }
        
        // Check for partial word matches
        const searchWords = searchTerm.split(' ').filter(word => word.length > 0);
        searchWords.forEach(function(word) {
          if (title.includes(word)) score += 1;
          if (description.includes(word)) score += 0.5;
          if (difficulty.includes(word)) score += 1;
        });
        
        return { tutorial: tutorial, score: score };
      });
      
      // Filter tutorials with score > 0 and sort by score
      const filteredTutorials = searchResults
        .filter(result => result.score > 0)
        .sort((a, b) => b.score - a.score)
        .map(result => result.tutorial);
      
      // Update display
      tutorials.forEach(function(tutorial) {
        tutorial.style.display = 'none';
      });
      
      if (filteredTutorials.length > 0) {
        filteredTutorials.forEach(function(tutorial) {
          tutorial.style.display = 'block';
        });
        noResults.classList.add('hidden');
        tutorialsGrid.classList.remove('hidden');
        
        // Update no results message with search term
        updateNoResultsMessage(searchTerm, filteredTutorials.length);
      } else {
        tutorialsGrid.classList.add('hidden');
        noResults.classList.remove('hidden');
        updateNoResultsMessage(searchTerm, 0);
      }
    }
    
    function updateNoResultsMessage(searchTerm, resultCount) {
      const noResultsTitle = document.querySelector('#no-results h3');
      const noResultsText = document.querySelector('#no-results p');
      
      if (resultCount === 0 && searchTerm) {
        if (noResultsTitle) noResultsTitle.textContent = `No tutorials found for "${searchTerm}"`;
        if (noResultsText) noResultsText.textContent = 'Try a different search term or browse our popular topics above.';
      } else {
        if (noResultsTitle) noResultsTitle.textContent = 'No tutorials found';
        if (noResultsText) noResultsText.textContent = 'Try adjusting your search or browse our popular topics above.';
      }
    }
    
    function clearSearch() {
      if (heroSearch) {
        heroSearch.value = '';
        heroSearch.focus();
      }
      hideSuggestions();
      searchTutorials();
    }
    
    function handleTagClick(tagName) {
      if (heroSearch) {
        heroSearch.value = tagName;
        heroSearch.focus();
        hideSuggestions();
        searchTutorials();
      }
    }
    
    // Create debounced versions
    const debouncedSearch = debounce(searchTutorials, 300);
    const debouncedTypeAhead = debounce(function(query) {
      const suggestions = generateSuggestions(query);
      showSuggestions(suggestions);
    }, 150);
    
    // Event listeners
    if (heroSearch) {
      heroSearch.addEventListener('input', function(e) {
        const query = e.target.value;
        
        // Show type-ahead suggestions
        if (query.length >= 2) {
          debouncedTypeAhead(query);
        } else {
          hideSuggestions();
        }
        
        // Trigger search
        debouncedSearch();
      });
      
      // Handle keyboard navigation
      heroSearch.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (currentSuggestions.length > 0) {
            selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
            highlightSuggestion(selectedSuggestionIndex);
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (currentSuggestions.length > 0) {
            selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
            highlightSuggestion(selectedSuggestionIndex);
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedSuggestionIndex >= 0 && currentSuggestions.length > 0) {
            selectSuggestion(selectedSuggestionIndex);
          } else {
            hideSuggestions();
            searchTutorials();
          }
        } else if (e.key === 'Escape') {
          if (searchSuggestions.classList.contains('hidden')) {
            clearSearch();
          } else {
            hideSuggestions();
          }
        } else if (e.key === 'Tab') {
          hideSuggestions();
        }
      });
      
      // Hide suggestions when clicking outside
      heroSearch.addEventListener('blur', function(e) {
        setTimeout(() => {
          if (!searchSuggestions.contains(document.activeElement)) {
            hideSuggestions();
          }
        }, 150);
      });
      
      // Show suggestions when focusing if there's text
      heroSearch.addEventListener('focus', function() {
        if (heroSearch.value.length >= 2) {
          const suggestions = generateSuggestions(heroSearch.value);
          showSuggestions(suggestions);
        }
      });
      
      // Add search icon functionality
      const searchIcon = heroSearch.parentElement.querySelector('svg');
      if (searchIcon) {
        searchIcon.style.cursor = 'pointer';
        searchIcon.addEventListener('click', function() {
          hideSuggestions();
          searchTutorials();
        });
      }
    }
    
    if (clearAllFilters) {
      clearAllFilters.addEventListener('click', clearSearch);
    }
    
    // Popular tag functionality
    popularTags.forEach(function(tag) {
      tag.addEventListener('click', function() {
        const tagName = tag.dataset.tag;
        if (tagName) {
          handleTagClick(tagName);
        }
      });
    });
    
    // Initial load - show all tutorials
    searchTutorials();
    
    // Auto-focus search on page load (optional)
    if (heroSearch && window.innerWidth > 768) { // Only on desktop
      setTimeout(() => heroSearch.focus(), 100);
    }
  });
</script>

<style>
  .tutorial-item {
    transition: opacity 0.3s ease;
  }
  
  .popular-tag:hover {
    transform: translateY(-1px);
  }
</style>